//279. 完全平方数
//        给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。
//
//        示例 1:
//
//        输入: n = 12
//        输出: 3
//        解释: 12 = 4 + 4 + 4.
//        示例 2:
//
//        输入: n = 13
//        输出: 2
//        解释: 13 = 4 + 9.
//
//        来源：力扣（LeetCode）
//        链接：https://leetcode-cn.com/problems/perfect-squares
//        著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



//动态规划，dp[i+j*j]=min(dp[i]+1,dp[i+j*j]） i+j*j表示是由i和j*j组成的，这样的话就是在i的基础上加上一个数的平方，所以dp[i+j*j]=dp[i]+1。但是这个数是会更新的比如对于9，最开始i=0;j=3时，可以组成9，所以dp[9]=dp[0]+1=1,当i=5,j=2的时候也会等于9，所以dp[9]=dp[5]+1,由于这个dp[9]与上一个dp比较较大所以不更新；当i=8,j=1的时候又会碰见等于9的情况，所以dp[9]=dp[8]+1,还是大于最开始的dp所以不更新，最后dp[9]=1。比如在12的时候 ：
//
//        i=3，j=3的时候，dp[12]=dp[3]+1=4；
//
//        i=8,j=2的时候，dp[12]=dp[8]+1=3,更新dp[12]为3；
//
//        i=11,j=1的时候，dp[12]=dp[11]+1=4
//
//        所以最后dp[12]=3



//动态规划：dp[n] 代表n得方法数
//dp[i+j*j] = min(dp[i]+1,dp[i+j*j]) 表示一个数为前一个数加上j的平方，但是n可以有很多种i+j*j的组合
//那么dp[i+j*j]的值为i+jj的组成方法数，等于前一个数i的方法数+1的最小值,




package DP;

public class code279 {
    public int numSquares(int n) {
        int[] dp = new int[n+1];
        dp[0] = 0;

        for (int i =1; i<n+1; i++){
            dp[i] = Integer.MAX_VALUE;
        }

        for (int i = 0; i<=n; i++){
            for (int j = 0; i+j*j<=n; j++){
                dp[i+j*j] = Math.min(dp[i]+1,dp[i+j*j]);
            }
        }

        return dp[n];
    }
}
